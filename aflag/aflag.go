package aflag

import (
	"io"
	"strings"

	"github.com/mlctrez/javaclassparser/ioutil"
)

type flag struct {
	Bits uint16
	Name string
}

// http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.5-200-A.1

/*
Table 4.5-A. Field access and property flags
Flag Name		Value	Interpretation
ACC_PUBLIC		0x0001	Declared public; may be accessed from outside its package.
ACC_PRIVATE		0x0002	Declared private; usable only within the defining class.
ACC_PROTECTED	0x0004	Declared protected; may be accessed within subclasses.
ACC_STATIC		0x0008	Declared static.
ACC_FINAL		0x0010	Declared final; never directly assigned to after object construction (JLS ยง17.5).
ACC_VOLATILE	0x0040	Declared volatile; cannot be cached.
ACC_TRANSIENT	0x0080	Declared transient; not written or read by a persistent object manager.
ACC_SYNTHETIC	0x1000	Declared synthetic; not present in the source code.
ACC_ENUM		0x4000	Declared as an element of an enum.
*/

type FieldAccessFlags uint16

var fi [9]flag

func init() {
	fi[0] = flag{0x0001, "public"}
	fi[1] = flag{0x0002, "private"}
	fi[2] = flag{0x0004, "protected"}
	fi[3] = flag{0x0008, "static"}
	fi[4] = flag{0x0010, "final"}
	fi[5] = flag{0x0040, "volatile"}
	fi[6] = flag{0x0080, "transient"}
	fi[7] = flag{0x1000, "synthetic"}
	fi[8] = flag{0x4000, "enum"}
}

func ReadFieldAccessFlags(r io.Reader) FieldAccessFlags {
	var af uint16
	if err := ioutil.ReadUint16(r, &af); err != nil {
		panic(err)
	}
	return FieldAccessFlags(af)
}

func (f FieldAccessFlags) String() string {
	var mods []string
	for _, flag := range fi {
		if (uint16(f) & flag.Bits) != 0 {
			mods = append(mods, flag.Name)
		}
	}
	return strings.Join(mods, " ")
}

// http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6-200-A.1
/*
Table 4.6-A. Method access and property flags
Flag Name	Value	Interpretation
ACC_PUBLIC			0x0001	Declared public; may be accessed from outside its package.
ACC_PRIVATE			0x0002	Declared private; accessible only within the defining class.
ACC_PROTECTED		0x0004	Declared protected; may be accessed within subclasses.
ACC_STATIC			0x0008	Declared static.
ACC_FINAL			0x0010	Declared final; must not be overridden (ยง5.4.5).
ACC_SYNCHRONIZED	0x0020	Declared synchronized; invocation is wrapped by a monitor use.
ACC_BRIDGE			0x0040	A bridge method, generated by the compiler.
ACC_VARARGS			0x0080	Declared with variable number of arguments.
ACC_NATIVE			0x0100	Declared native; implemented in a language other than Java.
ACC_ABSTRACT		0x0400	Declared abstract; no implementation is provided.
ACC_STRICT			0x0800	Declared strictfp; floating-point mode is FP-strict.
ACC_SYNTHETIC		0x1000	Declared synthetic; not present in the source code.
*/

type MethodAccessFlags uint16

var mi [12]flag

func init() {
	mi[0] = flag{0x0001, "public"}
	mi[1] = flag{0x0002, "private"}
	mi[2] = flag{0x0004, "protected"}
	mi[3] = flag{0x0008, "static"}
	mi[4] = flag{0x0010, "final"}
	mi[5] = flag{0x0020, "synchronized"}
	mi[6] = flag{0x0040, "bridge"}
	mi[7] = flag{0x0080, "varargs"}
	mi[8] = flag{0x0100, "native"}
	mi[9] = flag{0x0400, "abstract"}
	mi[10] = flag{0x0800, "strict"}
	mi[11] = flag{0x1000, "synthetic"}
}

func ReadMethodAccessFlags(r io.Reader) MethodAccessFlags {
	var af uint16
	if err := ioutil.ReadUint16(r, &af); err != nil {
		panic(err)
	}
	return MethodAccessFlags(af)
}

func (f MethodAccessFlags) String() string {
	var mods []string
	for _, flag := range mi {
		if (uint16(f) & flag.Bits) != 0 {
			mods = append(mods, flag.Name)
		}
	}
	return strings.Join(mods, " ")
}

// http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1-200-E.1
/*
Table 4.1-A. Class access and property modifiers
Flag Name	Value	Interpretation
ACC_PUBLIC		0x0001	Declared public; may be accessed from outside its package.
ACC_FINAL		0x0010	Declared final; no subclasses allowed.
ACC_SUPER		0x0020	Treat superclass methods specially when invoked by the invokespecial instruction.
ACC_INTERFACE	0x0200	Is an interface, not a class.
ACC_ABSTRACT	0x0400	Declared abstract; must not be instantiated.
ACC_SYNTHETIC	0x1000	Declared synthetic; not present in the source code.
ACC_ANNOTATION	0x2000	Declared as an annotation type.
ACC_ENUM		0x4000	Declared as an enum type.
*/

type ClassAccessFlags uint16

var ci [9]flag

func init() {
	ci[0] = flag{0x0001, "public"}
	ci[1] = flag{0x0010, "final"}
	ci[2] = flag{0x0020, "super"}
	ci[3] = flag{0x0200, "interface"}
	ci[4] = flag{0x0400, "abstract"}
	ci[5] = flag{0x1000, "synthetic"}
	ci[6] = flag{0x2000, "annotation"}
	ci[7] = flag{0x4000, "enum"}
}

func ReadClassAccessFlags(r io.Reader) ClassAccessFlags {
	var af uint16
	if err := ioutil.ReadUint16(r, &af); err != nil {
		panic(err)
	}
	return ClassAccessFlags(af)
}

func (f ClassAccessFlags) String() string {
	var mods []string

	for _, flag := range ci {
		if (uint16(f) & flag.Bits) != 0 {
			mods = append(mods, flag.Name)
		}
	}
	return strings.Join(mods, " ")
}

// http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.24
/*
The value of the access_flags item is as follows:
0x0010 (ACC_FINAL)
Indicates that the formal parameter was declared final.
0x1000 (ACC_SYNTHETIC)
Indicates that the formal parameter was not explicitly or implicitly declared in source code,
according to the specification of the language in which the source code was written (JLS ยง13.1).
(The formal parameter is an implementation artifact of the compiler which produced this class file.)
0x8000 (ACC_MANDATED)
Indicates that the formal parameter was implicitly declared in source code, according to the
specification of the language in which the source code was written (JLS ยง13.1). (The formal
parameter is mandated by a language specification, so all compilers for the language must emit it.)
*/

type MethodParamterAccessFlags uint16

var mp [3]flag

func init() {
	mp[0] = flag{0x0001, "final"}
	mp[1] = flag{0x1000, "synthetic"}
	mp[2] = flag{0x8000, "mandated"}
}

func (f MethodParamterAccessFlags) String() string {
	var mods []string
	for _, flag := range mp {
		if (uint16(f) & flag.Bits) != 0 {
			mods = append(mods, flag.Name)
		}
	}
	return strings.Join(mods, " ")
}

//const ACC_PUBLIC AccessFlag = 0x0001
//const ACC_PRIVATE AccessFlag = 0x0002
//const ACC_PROTECTED AccessFlag = 0x0004
//const ACC_STATIC AccessFlag = 0x0008
//const ACC_FINAL AccessFlag = 0x0010
//const ACC_SYNCHRONIZED AccessFlag = 0x0020
//const ACC_VOLATILE AccessFlag = 0x0040
//const ACC_BRIDGE AccessFlag = 0x0040
//const ACC_TRANSIENT AccessFlag = 0x0080
//const ACC_VARARGS AccessFlag = 0x0080
//const ACC_NATIVE AccessFlag = 0x0100
//const ACC_INTERFACE AccessFlag = 0x0200
//const ACC_ABSTRACT AccessFlag = 0x0400
//const ACC_STRICT AccessFlag = 0x0800
//const ACC_SYNTHETIC AccessFlag = 0x1000
//const ACC_ANNOTATION AccessFlag = 0x2000
//const ACC_ENUM AccessFlag = 0x4000
//const ACC_MANDATED AccessFlag = 0x8000
//const ACC_SUPER AccessFlag = 0x0020
//
//type AccessFlag uint16
//
//func (f AccessFlag) String() string {
//	var mods []string
//	if (ACC_PUBLIC & f) != 0 {
//		mods = append(mods, "public")
//	}
//	if (ACC_PRIVATE & f) != 0 {
//		mods = append(mods, "private")
//	}
//	if (ACC_PROTECTED & f) != 0 {
//		mods = append(mods, "protected")
//	}
//	if (ACC_STATIC & f) != 0 {
//		mods = append(mods, "static")
//	}
//	if (ACC_FINAL & f) != 0 {
//		mods = append(mods, "final")
//	}
//	if (ACC_SYNCHRONIZED & f) != 0 {
//		mods = append(mods, "synchronized")
//	}
//	if (ACC_VOLATILE & f) != 0 {
//		mods = append(mods, "volatile")
//	}
//	if (ACC_BRIDGE & f) != 0 {
//		mods = append(mods, "bridge")
//	}
//	if (ACC_TRANSIENT & f) != 0 {
//		mods = append(mods, "transient")
//	}
//	if (ACC_VARARGS & f) != 0 {
//		mods = append(mods, "varargs")
//	}
//	if (ACC_NATIVE & f) != 0 {
//		mods = append(mods, "native")
//	}
//	if (ACC_INTERFACE & f) != 0 {
//		mods = append(mods, "interface")
//	}
//	if (ACC_ABSTRACT & f) != 0 {
//		mods = append(mods, "abstract")
//	}
//	if (ACC_STRICT & f) != 0 {
//		mods = append(mods, "strict")
//	}
//	if (ACC_SYNTHETIC & f) != 0 {
//		mods = append(mods, "synthetic")
//	}
//	if (ACC_ANNOTATION & f) != 0 {
//		mods = append(mods, "annotation")
//	}
//	if (ACC_ENUM & f) != 0 {
//		mods = append(mods, "enum")
//	}
//	if (ACC_MANDATED & f) != 0 {
//		mods = append(mods, "mandated")
//	}
//	if (ACC_SUPER & f) != 0 {
//		mods = append(mods, "super")
//	}
//	return strings.Join(mods, " ")
//}

//func (f *AccessFlag) ValidateClass() error {
//	// TODO: revisit this
//	if (*f & ACC_INTERFACE) != 0 {
//		*f |= ACC_ABSTRACT
//	}
//	if ((*f & ACC_ABSTRACT) != 0) && ((*f & ACC_FINAL) != 0) {
//		return errors.New("class can't be both final and abstract")
//	}
//	return nil
//}
//
//func Read(r io.Reader) AccessFlag {
//	var af uint16
//	if err := ioutil.ReadUint16(r, &af); err != nil {
//		panic(err)
//	}
//	return AccessFlag(af)
//}
